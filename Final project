Project Report: Movie Recommendation System

1. Introduction
With the rise of online platforms, recommendation systems are essential to enhance user satisfaction. Thisproject builds a Movie Recommendation System using Content-Based and Collaborative Filtering with aStreamlit interface.

2. Abstract
The system utilizes the MovieLens dataset and combines two key models:
- Content-Based Filtering: Suggests similar movies based on genres using TF-IDF and Cosine Similarity.
- Collaborative Filtering: Predicts user preferences via SVD-based matrix factorization.
A Streamlit app integrates both models for a user-friendly experience.

3. Tools & Technologies Used
- Python, Pandas, NumPy, Scikit-learn, Surprise, Streamlit, Matplotlib, Seaborn

4. Steps Involved in Building the Project
 A. Data Preprocessing: Loaded MovieLens data, cleaned missing values.
 B. Content-Based Filtering: TF-IDF on genres, Cosine Similarity for top recommendations.
 C. Collaborative Filtering: SVD model via Surprise library predicts ratings.
 D. Streamlit Web App: Clean UI allowing movie title or user ID input.
 E. Evaluation: Cosine scores, RMSE, MAE for model checks.

5. Conclusion
A dual-model recommendation engine is developed and deployed via Streamlit. It shows ML, NLP, anddeployment skills and is ideal for AI/Data Science job portfolios.

6. Future Enhancements
- Sentiment-based filtering
- Deep Learning methods
- Full deployment on cloud platforms


Project Code Snippet:-

# Data Preprocessing (MovieLens)

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load datasets
movies = pd.read_csv('movies.csv')
ratings = pd.read_csv('ratings.csv')

# Content-Based Filtering - TFIDF on genres
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(movies['genres'].fillna(''))
cos_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Content-Based Recommendation Function

def content_recommend(movie_title, top_n=5):
    idx = movies[movies['title'] == movie_title].index[0]
    sim_scores = list(enumerate(cos_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    movie_indices = [i[0] for i in sim_scores[1:top_n+1]]
    return movies['title'].iloc[movie_indices]

print(content_recommend('Toy Story (1995)'))

# Collaborative Filtering (Using Surprise Library)

from surprise import Dataset, Reader, SVD
from surprise.model_selection import train_test_split

reader = Reader(rating_scale=(0.5, 5))
data = Dataset.load_from_df(ratings[['userId', 'movieId', 'rating']], reader)
trainset, testset = train_test_split(data, test_size=0.2)

model = SVD()
model.fit(trainset)
pred = model.test(testset)

# Collaborative Recommendation Function

def collab_recommend(user_id, top_n=5):
    movie_ids = ratings['movieId'].unique()
    predictions = [model.predict(user_id, movie_id) for movie_id in movie_ids]
    pred_ratings = sorted(predictions, key=lambda x: x.est, reverse=True)[:top_n]
    movie_titles = movies.set_index('movieId').loc[[pred.iid for pred in pred_ratings]]['title']
    return movie_titles.values

print(collab_recommend(1))

# Simple Streamlit UI (app.py)

import streamlit as st

st.title('ðŸŽ¬ Movie Recommendation System')
option = st.selectbox('Select a Movie:', movies['title'].values)

if st.button('Recommend (Content-Based)'):
    result = content_recommend(option)
    st.write("Top 5 similar movies:")
    for movie in result:
        st.write(movie)

user_id = st.number_input('Enter User ID for Collaborative Filtering:', min_value=1, step=1)
if st.button('Recommend (Collaborative)'):
    result = collab_recommend(int(user_id))
    st.write("Top 5 movie predictions:")
    for movie in result:
        st.write(movie)

Output:-

# Top 5 Recommendations:-

['A Bug\'s Life (1995)', 'Monsters, Inc. (2001)', 'Finding Nemo (2003)', 'Shrek (2001)', 'Ice Age (2002)']
